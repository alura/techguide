{"version":3,"file":"useLazyQuery.js","sourceRoot":"","sources":["../../../src/react/hooks/useLazyQuery.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,KAAK,MAAM,SAAS,CAAC;AAGjC,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAOxD,OAAO,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AAEvD,2EAA2E;AAC3E,+DAA+D;AAC/D,IAAM,aAAa,GAAG;IACpB,SAAS;IACT,WAAW;IACX,WAAW;IACX,aAAa;IACb,cAAc;IACd,iBAAiB;CACT,CAAC;AAEX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,UAAU,YAAY,CAI1B,KAA0D,EAC1D,OAAmE;;IAEnE,IAAM,cAAc,GAClB,KAAK,CAAC,MAAM,EAAwD,CAAC;IACvE,IAAM,UAAU,GAAG,KAAK,CAAC,MAAM,EAA2C,CAAC;IAC3E,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,EAE1B,CAAC;IACJ,IAAM,MAAM,GAAG,YAAY,CAAC,OAAO,EAAE,cAAc,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;IACnE,IAAM,QAAQ,GAAG,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,KAAK,mCAAI,KAAK,CAAC;IAExC,uEAAuE;IACvE,yDAAyD;IACzD,UAAU,CAAC,OAAO,GAAG,OAAO,CAAC;IAC7B,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC;IAE5B,IAAM,aAAa,GAAG,gBAAgB,CACpC,eAAe,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC,EAC1C,QAAQ,CACT,CAAC;IAEF,IAAM,cAAc,GAAG,aAAa,CAAC,QAAQ,uBACxC,MAAM,KACT,IAAI,EAAE,CAAC,cAAc,CAAC,OAAO,IAC7B,CAAC;IAEH,IAAM,kBAAkB,GACtB,cAAc,CAAC,UAAU,CAAC,OAAO,CAAC,kBAAkB;QACpD,aAAa,CAAC,qBAAqB,EAAE,CAAC;IAEhC,IAAA,gBAAgB,GAAqB,aAAa,iBAAlC,EAAE,cAAc,GAAK,aAAa,eAAlB,CAAmB;IAC3D,6EAA6E;IAC7E,IAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC;QACjC,IAAM,YAAY,GAAwB,EAAE,CAAC;gCAClC,GAAG;YACZ,IAAM,MAAM,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC;YACnC,YAAY,CAAC,GAAG,CAAC,GAAG;gBAClB,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;oBAC5B,cAAc,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC7C,sEAAsE;oBACtE,gBAAgB,EAAE,CAAC;gBACrB,CAAC;gBACD,oDAAoD;gBACpD,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YACvC,CAAC,CAAC;;QAVJ,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa;YAA1B,IAAM,GAAG,sBAAA;oBAAH,GAAG;SAWb;QAED,OAAO,YAAY,CAAC;IACtB,CAAC,EAAE,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC,CAAC;IAEvC,IAAM,MAAM,GAAG,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC;IACxC,IAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAC1B,cAAM,OAAA,gCACD,cAAc,GACd,YAAY,KACf,MAAM,QAAA,IACN,EAJI,CAIJ,EACF,CAAC,cAAc,EAAE,YAAY,EAAE,MAAM,CAAC,CACvC,CAAC;IAEF,IAAM,OAAO,GAAG,KAAK,CAAC,WAAW,CAC/B,UAAC,cAAc;QACb,cAAc,CAAC,OAAO;YACpB,cAAc,CAAC,CAAC,uBAET,cAAc,KACjB,WAAW,EAAE,cAAc,CAAC,WAAW,IAAI,kBAAkB,IAEjE,CAAC,CAAC;gBACE,WAAW,EAAE,kBAAkB;aAChC,CAAC;QAEN,IAAM,OAAO,GAAG,YAAY,CAAC,UAAU,CAAC,OAAO,aAC7C,KAAK,EAAE,QAAQ,CAAC,OAAO,IACpB,cAAc,CAAC,OAAO,EACzB,CAAC;QAEH,IAAM,OAAO,GAAG,aAAa;aAC1B,YAAY,uBAAM,OAAO,KAAE,IAAI,EAAE,KAAK,IAAG;aACzC,IAAI,CAAC,UAAC,WAAW,IAAK,OAAA,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,YAAY,CAAC,EAAxC,CAAwC,CAAC,CAAC;QAEnE,yEAAyE;QACzE,wDAAwD;QACxD,OAAO,CAAC,KAAK,CAAC,cAAO,CAAC,CAAC,CAAC;QAExB,OAAO,OAAO,CAAC;IACjB,CAAC,EACD,CAAC,YAAY,EAAE,kBAAkB,EAAE,aAAa,CAAC,CAClD,CAAC;IAEF,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC3B,CAAC","sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"rehackt\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const { forceUpdateState, obsQueryFields } = internalState;\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = obsQueryFields[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, [forceUpdateState, obsQueryFields]);\n\n  const called = !!execOptionsRef.current;\n  const result = React.useMemo(\n    () => ({\n      ...useQueryResult,\n      ...eagerMethods,\n      called,\n    }),\n    [useQueryResult, eagerMethods, called]\n  );\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current =\n        executeOptions ?\n          {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    [eagerMethods, initialFetchPolicy, internalState]\n  );\n\n  return [execute, result];\n}\n"]}